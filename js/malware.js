document.addEventListener("DOMContentLoaded", function () {
  // Elements for profile dropdown
  const authNavItem = document.getElementById("auth-nav-item");
  const loginLink = document.getElementById("login-link");
  const profileContainer = document.getElementById("profile-container");
  const profileAvatar = document.getElementById("profile-avatar");
  const profileInitial = document.getElementById("profile-initial");
  const profileName = document.getElementById("profile-name");
  const logoutBtn = document.getElementById("logout-btn");

  // Setup logout button event listener
  if (logoutBtn) {
    logoutBtn.addEventListener("click", function (e) {
      e.preventDefault();
      logout();
    });
  }

  // Function to get user initial from name or email
  function getUserInitial(userInfo) {
    if (!userInfo) return "?";

    if (userInfo.displayName) {
      return userInfo.displayName.charAt(0).toUpperCase();
    } else if (userInfo.fullname) {
      return userInfo.fullname.charAt(0).toUpperCase();
    } else if (userInfo.email) {
      return userInfo.email.charAt(0).toUpperCase();
    } else if (userInfo.username) {
      return userInfo.username.charAt(0).toUpperCase();
    }

    return "U";
  }

  // Check for Firebase auth state
  if (firebase && firebase.auth) {
    firebase.auth().onAuthStateChanged(function (user) {
      if (user) {
        // User is signed in with Firebase
        if (loginLink) loginLink.style.display = "none";
        if (profileContainer) profileContainer.style.display = "block";
        if (profileInitial) profileInitial.textContent = getUserInitial(user);
        if (profileName) profileName.textContent = ""; // No account name text

        // Store in localStorage for backward compatibility
        localStorage.setItem(
          "currentUser",
          JSON.stringify({
            username: user.email,
            fullname: user.displayName || "Cyber Academy User",
            initial: getUserInitial(user),
            uid: user.uid // Store UID for database lookups
          })
        );
        
        console.log("[DEBUG] User signed in with Firebase:", user.uid);
      } else {
        // Check localStorage for backward compatibility
        const currentUser = JSON.parse(localStorage.getItem("currentUser"));
        if (currentUser) {
          if (loginLink) loginLink.style.display = "none";
          if (profileContainer) profileContainer.style.display = "block";
          if (profileInitial)
            profileInitial.textContent = getUserInitial(currentUser);
          if (profileName) profileName.textContent = ""; // No account name text
            
          console.log("[DEBUG] Using stored user from localStorage:", currentUser.uid || "no UID");
        } else {
          if (loginLink) loginLink.style.display = "block";
          if (profileContainer) profileContainer.style.display = "none";
          console.log("[DEBUG] No user found in Firebase or localStorage");
        }
      }
      
      // Load progress after authentication check
      loadProgressFromFirebase();
    });
  } else {
    // Fallback for older version
    const currentUser = JSON.parse(localStorage.getItem("currentUser"));
    if (currentUser) {
      if (loginLink) loginLink.style.display = "none";
      if (profileContainer) profileContainer.style.display = "block";
      if (profileInitial)
        profileInitial.textContent = getUserInitial(currentUser);
      if (profileName) profileName.textContent = ""; // No account name text
      
      console.log("[DEBUG] Firebase auth unavailable, using localStorage user");
    } else {
      if (loginLink) loginLink.style.display = "block";
      if (profileContainer) profileContainer.style.display = "none";
      console.log("[DEBUG] No Firebase auth and no localStorage user");
    }
    
    // Load progress after authentication check
    loadProgressFromFirebase();
  }

  // Initialize variables for completed sections and quizzes
  let completedSections = [];
  let completedQuizzes = [];

  // Define topic progression order
  const topicOrder = [
    "types-of-malware",
    "ransomware",
    "spyware",
    "trojans",
    "worms",
  ];

  // Check if user is logged in with Firebase
  function checkUserLoggedIn() {
    if (firebase && firebase.auth) {
      return firebase.auth().currentUser !== null;
    }
    // Fallback to localStorage check for backward compatibility
    return localStorage.getItem("currentUser") !== null;
  }

  // Function to load progress data from Firebase (placeholder)
  // In a production app, you would load actual progress from Firebase Firestore
  function loadProgressFromFirebase() {
    // Reset progress for not logged in users
    if (!checkUserLoggedIn()) {
      completedSections = [];
      completedQuizzes = [];
      updateProgress();
      return;
    }

    // Get the current user from Firebase
    let userId = null;
    
    if (firebase && firebase.auth && firebase.auth().currentUser) {
      userId = firebase.auth().currentUser.uid;
      console.log("[DEBUG] Loading malware progress using Firebase user:", userId);
    } else {
      // Check if we have a user ID in localStorage
      const localUser = JSON.parse(localStorage.getItem("currentUser"));
      if (localUser && localUser.uid) {
        userId = localUser.uid;
        console.log("[DEBUG] Loading malware progress using localStorage UID:", userId);
      }
    }
    
    if (userId) {
      // Load progress from Realtime Database
      const userProgressRef = firebase.database().ref(`userProgress/${userId}/modules/malwareInfections`);
      
      userProgressRef.once('value')
        .then((snapshot) => {
          const data = snapshot.val() || {};
          
          console.log("[DEBUG] Malware data loaded from Firebase:", data);
          
          // Load progress data
          completedSections = data.completedSections || [];
          completedQuizzes = data.completedQuizzes || [];
          
          console.log("[DEBUG] Setting completedSections:", completedSections);
          console.log("[DEBUG] Setting completedQuizzes:", completedQuizzes);
          
          // Update localStorage as backup
          localStorage.setItem("malwareCompletedSections", JSON.stringify(completedSections));
          localStorage.setItem("malwareCompletedQuizzes", JSON.stringify(completedQuizzes));
          
          // If localStorage has data but database doesn't, sync to database
          if (completedSections.length === 0 && completedQuizzes.length === 0) {
            const localSections = JSON.parse(localStorage.getItem("malwareCompletedSections")) || [];
            const localQuizzes = JSON.parse(localStorage.getItem("malwareCompletedQuizzes")) || [];
            
            if (localSections.length > 0 || localQuizzes.length > 0) {
              console.log("[DEBUG] Found data in localStorage, syncing to Firebase");
              completedSections = localSections;
              completedQuizzes = localQuizzes;
              
              // Sync localStorage data to database
              saveProgressToFirebase();
            }
          }
          
          initializeProgressUI();
          refreshProgressIndicators(); // Force a UI refresh
          
          // Add a small delay to ensure the UI updates properly
          setTimeout(() => {
            updateProgress();
            refreshProgressIndicators();
          }, 500);
        })
        .catch((error) => {
          console.error("[DEBUG] Error loading progress from Firebase:", error);
          
          // Fallback to localStorage
          completedSections = JSON.parse(localStorage.getItem("malwareCompletedSections")) || [];
          completedQuizzes = JSON.parse(localStorage.getItem("malwareCompletedQuizzes")) || [];
          initializeProgressUI();
          refreshProgressIndicators(); // Force a UI refresh
        });
    } else {
      // Fallback to localStorage for non-Firebase users
      console.log("[DEBUG] No user ID found, using localStorage only");
      completedSections = JSON.parse(localStorage.getItem("malwareCompletedSections")) || [];
      completedQuizzes = JSON.parse(localStorage.getItem("malwareCompletedQuizzes")) || [];
      initializeProgressUI();
      refreshProgressIndicators(); // Force a UI refresh
    }
  }
  
  // Function to save progress to Firebase
  function saveProgressToFirebase() {
    let userId = null;
    
    if (firebase && firebase.auth && firebase.auth().currentUser) {
      userId = firebase.auth().currentUser.uid;
    } else {
      // Try to get UID from localStorage
      const localUser = JSON.parse(localStorage.getItem("currentUser"));
      if (localUser && localUser.uid) {
        userId = localUser.uid;
      }
    }
    
    if (!userId) {
      // Save to localStorage as fallback
      localStorage.setItem("malwareCompletedSections", JSON.stringify(completedSections));
      localStorage.setItem("malwareCompletedQuizzes", JSON.stringify(completedQuizzes));
      return;
    }
    
    // Calculate progress percentage
    const progressPercentage = (completedSections.length / topicOrder.length) * 100;
    
    // Reference to user's progress data
    const userProgressRef = firebase.database().ref(`userProgress/${userId}/modules/malwareInfections`);
    
    // Update the database
    userProgressRef.update({
      completedSections: completedSections,
      completedQuizzes: completedQuizzes,
      lastUpdated: firebase.database.ServerValue.TIMESTAMP,
      progressPercentage: progressPercentage
    })
    .then(() => {
      console.log("Progress saved to Realtime Database");
      
      // Update localStorage as backup
      localStorage.setItem("malwareCompletedSections", JSON.stringify(completedSections));
      localStorage.setItem("malwareCompletedQuizzes", JSON.stringify(completedQuizzes));
      
      // Update overall user progress
      updateOverallProgress(userId);
      
      // Force UI refresh after saving
      setTimeout(() => {
        updateProgress();
        refreshProgressIndicators();
      }, 200);
    })
    .catch((error) => {
      console.error("Error saving progress to Realtime Database:", error);
      
      // Save to localStorage as backup
      localStorage.setItem("malwareCompletedSections", JSON.stringify(completedSections));
      localStorage.setItem("malwareCompletedQuizzes", JSON.stringify(completedQuizzes));
    });
  }
  
  // Update overall progress in user profile
  function updateOverallProgress(userId) {
    if (!firebase.database || !userId) return;
    
    // Get current module data
    const currentModuleData = {
      completedSections: completedSections,
      completedQuizzes: completedQuizzes,
      progressPercentage: (completedSections.length / topicOrder.length) * 100
    };

    // Reference to user's overall progress
    const userOverallRef = firebase.database().ref(`userProgress/${userId}`);
    
    // Get existing data first to calculate overall stats
    userOverallRef.once('value')
      .then((snapshot) => {
        const data = snapshot.val() || {};
        const modules = data.modules || {};
        
        // Update this module data
        modules.malwareInfections = currentModuleData;
        
        // Calculate overall progress
        let totalCompleted = 0;
        let totalTopics = 0;
        
        // Count completed topics from each module
        if (modules.introCybersec && modules.introCybersec.completedQuizzes) {
          totalTopics += 5; // Total topics in intro module
          totalCompleted += modules.introCybersec.completedQuizzes.length;
        }
        
        if (modules.attackTargets && modules.attackTargets.completedSections) {
          totalTopics += 5; // Total topics in attack targets module
          totalCompleted += modules.attackTargets.completedSections.length;
        }
        
        if (modules.phishingAttacks && modules.phishingAttacks.completedSections) {
          totalTopics += 4; // Total topics in phishing module
          totalCompleted += modules.phishingAttacks.completedSections.length;
        }
        
        if (modules.malwareInfections && modules.malwareInfections.completedSections) {
          totalTopics += 5; // Total topics in malware module
          totalCompleted += modules.malwareInfections.completedSections.length;
        }
        
        // Calculate completed modules count
        const completedModules = [
          modules.introCybersec?.progressPercentage === 100,
          modules.attackTargets?.progressPercentage === 100,
          modules.phishingAttacks?.progressPercentage === 100,
          modules.malwareInfections?.progressPercentage === 100
        ].filter(Boolean).length;
        
        // Update user progress document
        userOverallRef.update({
          modules: modules,
          completedModules: completedModules,
          totalModules: 4,
          completedTopics: totalCompleted,
          totalTopics: totalTopics,
          totalTimeMinutes: totalCompleted * 15, // Estimate 15 min per topic
          completionPercentage: (totalCompleted / totalTopics) * 100,
          lastUpdated: firebase.database.ServerValue.TIMESTAMP
        });
      })
      .catch(error => console.error("Error updating overall progress:", error));
  }

  // Load progress when page loads
  loadProgressFromFirebase();
  
  // Schedule a delayed UI refresh to ensure all progress indicators are properly displayed
  setTimeout(() => {
    console.log("[DEBUG] Running delayed UI refresh for malware module");
    updateProgress();
    refreshProgressIndicators();
    
    // Re-apply completed state to all progress nodes
    document.querySelectorAll(".progress-node").forEach(node => {
      const topicId = node.getAttribute("data-topic");
      if (completedSections.includes(topicId) || completedQuizzes.includes(topicId)) {
        node.classList.add("completed");
        
        // Also update the connecting line to this node
        const prevLine = node.previousElementSibling;
        if (prevLine && prevLine.classList.contains("progress-line")) {
          prevLine.classList.add("completed");
        }
      }
    });
    
    // Directly update the progress bar width
    const progressBar = document.getElementById("module-progress");
    if (progressBar) {
      const progressPercentage = (completedSections.length / topicOrder.length) * 100;
      progressBar.style.width = `${progressPercentage}%`;
    }
    
    // Make absolutely sure topic cards are correctly marked
    topicOrder.forEach(topicId => {
      const card = document.querySelector(`.target-card[data-target="${topicId}"]`);
      if (!card) return;
      
      // Handle completed topics
      if (completedSections.includes(topicId) || completedQuizzes.includes(topicId)) {
        card.classList.add("completed");
        
        // Make sure any debug lock overlays are hidden
        const debugLockOverlay = card.querySelector(".debug-lock-overlay");
        if (debugLockOverlay) {
          debugLockOverlay.style.display = "none";
        }
      }
      
      // Handle accessible but not completed topics
      if (isTopicAccessible(topicId) && !completedSections.includes(topicId) && !completedQuizzes.includes(topicId)) {
        card.classList.add("accessible");
        
        // Make sure any debug lock overlays are hidden
        const debugLockOverlay = card.querySelector(".debug-lock-overlay");
        if (debugLockOverlay) {
          debugLockOverlay.style.display = "none";
        }
      }
    });
  }, 1500); // Slightly longer delay for malware module

  function initializeProgressUI() {
    // Only show progress for logged in users
    if (!checkUserLoggedIn()) {
      // Reset all progress UI elements to initial state
      document.querySelectorAll(".target-card").forEach((card) => {
        card.classList.remove("completed");
      });

      document.querySelectorAll(".complete-btn").forEach((button) => {
        button.textContent = "Mark as Complete";
        button.disabled = false;
      });

      document.querySelectorAll(".topic-quiz-btn").forEach((button) => {
        button.textContent = "Check Answer";
        button.classList.remove("success");
        button.disabled = false;
      });

      document.querySelectorAll(".topic-quiz-results").forEach((result) => {
        result.style.display = "none";
      });

      document.querySelectorAll(".option").forEach((option) => {
        option.classList.remove("selected", "correct", "incorrect");
      });

      // Reset progress bar
      const progressBar = document.getElementById("module-progress");
      if (progressBar) {
        progressBar.style.width = "0%";
      }

      return;
    }

    // Update UI with progress data for logged in users
    completedSections.forEach((targetId) => {
      const card = document.querySelector(
        `.target-card[data-target="${targetId}"]`
      );
      if (card) {
        card.classList.add("completed");
      }

      document
        .querySelectorAll(`.complete-btn[data-target="${targetId}"]`)
        .forEach((button) => {
          button.textContent = "Completed";
          button.disabled = true;
        });
    });

    completedQuizzes.forEach((targetId) => {
      const card = document.querySelector(
        `.target-card[data-target="${targetId}"]`
      );
      if (card) {
        const quizContainer = card.querySelector(".topic-quiz");
        if (quizContainer) {
          const quizBtn = quizContainer.querySelector(".topic-quiz-btn");
          const correctOption = quizContainer.querySelector(
            '.option[data-correct="true"]'
          );
          const resultsDiv = quizContainer.querySelector(".topic-quiz-results");
          const correctAnswer = quizContainer.querySelector(".correct-answer");

          if (quizBtn && correctOption && resultsDiv && correctAnswer) {
            correctOption.classList.add("selected");
            resultsDiv.style.display = "block";
            correctAnswer.style.display = "block";
            quizBtn.textContent = "Correct!";
            quizBtn.classList.add("success");
            quizBtn.disabled = true;
          }
        }
      }
    });

    // Initialize topic accessibility
    updateTopicAccessibility();
    updateProgress();
  }

  document.querySelectorAll(".complete-btn").forEach((button) => {
    button.addEventListener("click", function (e) {
      // Only allow marking as complete if logged in
      if (!checkUserLoggedIn()) {
        alert("Please log in to track your progress");
        return;
      }

      const targetId = this.getAttribute("data-target");
      markAsComplete(targetId);
    });
  });

  const topicQuizButtons = document.querySelectorAll(".topic-quiz-btn");
  topicQuizButtons.forEach((button) => {
    button.addEventListener("click", function () {
      const quizContainer = this.closest(".topic-quiz");
      const resultsDiv = quizContainer.querySelector(".topic-quiz-results");
      const correctAnswer = quizContainer.querySelector(".correct-answer");
      const incorrectAnswer = quizContainer.querySelector(".incorrect-answer");
      const selectedOption = quizContainer.querySelector(".option.selected");
      const targetId = this.closest(".target-card").getAttribute("data-target");

      if (completedQuizzes.includes(targetId) && this.disabled) {
        return;
      }

      correctAnswer.style.display = "none";
      incorrectAnswer.style.display = "none";

      if (selectedOption) {
        resultsDiv.style.display = "block";

        if (selectedOption.getAttribute("data-correct") === "true") {
          correctAnswer.style.display = "block";

          // Only save progress if logged in
          if (checkUserLoggedIn() && !completedQuizzes.includes(targetId)) {
            completedQuizzes.push(targetId);
            
            // Save progress to Firebase
            saveProgressToFirebase();
            
            if (!completedSections.includes(targetId)) {
              markAsComplete(targetId);
            } else {
              updateProgress();
            }

            // Update accessibility for next topics
            updateTopicAccessibility();

            // Handle hardcoded debug lock overlays
            const topicMapping = {
              "types-of-malware": "ransomware",
              ransomware: "spyware",
              spyware: "trojans",
              trojans: "worms",
            };

            // Unlock the next section
            const nextTopic = topicMapping[targetId];
            if (nextTopic) {
              const nextTopicCard = document.querySelector(
                `.target-card[data-target="${nextTopic}"]`
              );
              if (nextTopicCard) {
                nextTopicCard.classList.add("accessible");

                // Hide any debug lock overlay
                const debugLockOverlay = nextTopicCard.querySelector(
                  ".debug-lock-overlay"
                );
                if (debugLockOverlay) {
                  debugLockOverlay.style.display = "none";
                }

                // Enable pointer events on all interactive elements
                nextTopicCard
                  .querySelectorAll(
                    ".attack-item, .topic-quiz .option, .topic-quiz-btn"
                  )
                  .forEach((el) => (el.style.pointerEvents = "auto"));

                // Remove grayscale filter
                nextTopicCard.style.filter = "none";
                nextTopicCard.style.pointerEvents = "auto";
              }
            }
          }

          this.textContent = "Correct!";
          this.classList.add("success");
          this.disabled = true;
          selectedOption.classList.add("correct");
        } else {
          incorrectAnswer.style.display = "block";
          this.textContent = "Try Again";
          selectedOption.classList.add("incorrect");
          selectedOption.classList.add("shake-animation");
          setTimeout(() => {
            selectedOption.classList.remove("shake-animation");
          }, 800);
        }
      } else {
        alert("Please select an answer first.");
      }
    });
  });

  document.querySelectorAll(".topic-quiz .option").forEach((option) => {
    option.addEventListener("click", function () {
      const questionDiv = this.closest(".question");
      const options = questionDiv.querySelectorAll(".option");

      options.forEach((opt) => {
        opt.classList.remove("selected");
        opt.classList.remove("incorrect");
        opt.classList.remove("shake-animation");
      });

      this.classList.add("selected");

      const quizContainer = this.closest(".topic-quiz");
      const resultsDiv = quizContainer.querySelector(".topic-quiz-results");
      const quizButton = quizContainer.querySelector(".topic-quiz-btn");

      if (quizButton.textContent === "Try Again") {
        resultsDiv.style.display = "none";
        quizButton.textContent = "Check Answer";
      }
    });
  });

  const attackItems = document.querySelectorAll(".attack-item");
  attackItems.forEach((item) => {
    item.addEventListener("click", function (e) {
      this.classList.toggle("expanded");
    });
  });

  function markAsComplete(targetId) {
    // Only proceed if user is logged in
    if (!checkUserLoggedIn()) {
      return;
    }

    if (!completedSections.includes(targetId)) {
      completedSections.push(targetId);
      
      // Save progress to Firebase
      saveProgressToFirebase();

      document
        .querySelectorAll(`.complete-btn[data-target="${targetId}"]`)
        .forEach((button) => {
          button.textContent = "Completed";
          button.disabled = true;
        });

      const card = document.querySelector(
        `.target-card[data-target="${targetId}"]`
      );
      if (card) {
        card.classList.add("completed");
      }

      // Update accessibility for next topics
      updateTopicAccessibility();
      updateProgress();
    }
  }

  // Function to determine if a topic should be accessible
  function isTopicAccessible(topicId) {
    const topicIndex = topicOrder.indexOf(topicId);

    // First topic is always accessible
    if (topicIndex === 0) return true;

    // For any other topic, the previous topic must be completed
    const previousTopicId = topicOrder[topicIndex - 1];
    return completedQuizzes.includes(previousTopicId);
  }

  // Update the visual state of all topics based on accessibility
  function updateTopicAccessibility() {
    topicOrder.forEach((topicId, index) => {
      const topicCard = document.querySelector(
        `.target-card[data-target="${topicId}"]`
      );
      if (!topicCard) return;

      const isAccessible = isTopicAccessible(topicId);

      // Update the progress tracker nodes
      const progressNode = document.querySelector(
        `.progress-node[data-topic="${topicId}"]`
      );
      if (progressNode) {
        progressNode.classList.remove("active", "completed", "locked");

        const baseTooltip = progressNode
          .getAttribute("data-tooltip")
          .split(" - ")[0];

        if (completedQuizzes.includes(topicId)) {
          progressNode.classList.add("completed");
          progressNode.setAttribute(
            "data-tooltip",
            `${baseTooltip} - Completed ✓`
          );
        } else if (isAccessible) {
          progressNode.classList.add("active");
          progressNode.setAttribute(
            "data-tooltip",
            `${baseTooltip} - In Progress`
          );
        } else {
          progressNode.classList.add("locked");
          const prevTopicName =
            index > 0
              ? topicOrder[index - 1]
                  .replace(/-/g, " ")
                  .replace(/\b\w/g, (l) => l.toUpperCase())
              : "";
          progressNode.setAttribute(
            "data-tooltip",
            `${baseTooltip} - Locked (Complete ${prevTopicName} first)`
          );
        }
      }

      // Update progress tracker lines
      if (index > 0) {
        const prevTopicId = topicOrder[index - 1];
        const progressLine = progressNode?.previousElementSibling;

        if (progressLine && progressLine.classList.contains("progress-line")) {
          progressLine.classList.toggle(
            "completed",
            completedQuizzes.includes(prevTopicId)
          );
        }
      }

      // Handle hardcoded debug-lock-overlay in the HTML
      const debugLockOverlay = topicCard.querySelector(".debug-lock-overlay");
      if (debugLockOverlay) {
        if (isAccessible) {
          // Hide the hardcoded lock overlay when the topic becomes accessible
          debugLockOverlay.style.display = "none";

          // Add accessible class to ensure the topic is fully unlocked
          topicCard.classList.add("accessible");

          // Make sure all interactive elements in this card are clickable
          topicCard
            .querySelectorAll(
              ".attack-item, .topic-quiz .option, .topic-quiz-btn"
            )
            .forEach((element) => {
              element.style.pointerEvents = "auto";
            });

          // Remove any grayscale filter from the card
          topicCard.style.filter = "none";
          topicCard.style.pointerEvents = "auto";
        } else {
          // Show the hardcoded lock overlay when the topic is not accessible
          debugLockOverlay.style.display = "flex";
        }
      }

      // Add/remove lock overlay
      if (!isAccessible && !topicCard.classList.contains("locked")) {
        // Lock the topic
        topicCard.classList.add("locked");

        // Add lock overlay if not already present
        if (!topicCard.querySelector(".lock-overlay") && !debugLockOverlay) {
          const lockOverlay = document.createElement("div");
          lockOverlay.className = "lock-overlay";

          const lockIcon = document.createElement("i");
          lockIcon.className = "fas fa-lock";
          lockOverlay.appendChild(lockIcon);

          const lockMessage = document.createElement("p");
          lockMessage.className = "lock-message";
          const prevTopicName =
            index > 0
              ? topicOrder[index - 1]
                  .replace(/-/g, " ")
                  .replace(/\b\w/g, (l) => l.toUpperCase())
              : "";
          lockMessage.textContent = `Complete "${prevTopicName}" to unlock`;
          lockOverlay.appendChild(lockMessage);

          topicCard.appendChild(lockOverlay);
        }
      } else if (isAccessible && topicCard.classList.contains("locked")) {
        // Unlock the topic
        topicCard.classList.remove("locked");

        // Add accessible class
        topicCard.classList.add("accessible");

        // Remove lock overlay
        const lockOverlay = topicCard.querySelector(".lock-overlay");
        if (lockOverlay) {
          lockOverlay.remove();
        }
      }
    });
  }

  function updateProgress() {
    console.log("[DEBUG] Updating malware progress bar with completed sections:", completedSections.length);
    const totalSections = 5;
    const progressBar = document.getElementById("module-progress");
    const overallProgress = document.getElementById("overall-progress");
    const topicsCompleted = document.getElementById("topics-completed");
    const quizzesPassed = document.getElementById("quizzes-passed");

    // Always set progress to 0 if not logged in
    if (!checkUserLoggedIn()) {
      if (progressBar) progressBar.style.width = "0%";
      if (overallProgress) overallProgress.style.width = "0%";
      if (topicsCompleted) topicsCompleted.textContent = "0";
      if (quizzesPassed) quizzesPassed.textContent = "0";
      return;
    }

    let progressPercentage = 0;
    const topicsWeight = 60;
    const topicsProgressPercentage =
      (completedSections.length / totalSections) * topicsWeight;
    const quizzesWeight = 40;
    const quizzesProgressPercentage =
      (completedQuizzes.length / totalSections) * quizzesWeight;
    progressPercentage = topicsProgressPercentage + quizzesProgressPercentage;
    progressPercentage = Math.round(progressPercentage);
    
    console.log("[DEBUG] Calculated progress percentage:", progressPercentage + "%");

    if (progressBar) {
      console.log("[DEBUG] Setting malware progress bar width to:", progressPercentage + "%");
      progressBar.style.width = `${progressPercentage}%`;
      
      // Force a repaint
      void progressBar.offsetWidth;
      
      // Set it again to ensure it's applied
      setTimeout(() => {
        progressBar.style.width = `${progressPercentage}%`;
      }, 50);
    }

    if (overallProgress) {
      overallProgress.style.width = `${progressPercentage}%`;
      void overallProgress.offsetWidth;
    }

    if (topicsCompleted) {
      topicsCompleted.textContent = completedSections.length;
    }

    if (quizzesPassed) {
      quizzesPassed.textContent = completedQuizzes.length;
    }
    
    // Also update all progress nodes
    document.querySelectorAll(".progress-node").forEach((node, index) => {
      const topicId = node.getAttribute("data-topic");
      if (!topicId) return;
      
      if (completedSections.includes(topicId) || completedQuizzes.includes(topicId)) {
        node.classList.add("completed");
        
        // Update the progress line before this node
        if (index > 0) {
          const prevNode = document.querySelectorAll(".progress-node")[index-1];
          if (!prevNode) return;
          
          const prevTopicId = prevNode.getAttribute("data-topic");
          if (completedSections.includes(prevTopicId) || completedQuizzes.includes(prevTopicId)) {
            const line = node.previousElementSibling;
            if (line && line.classList.contains("progress-line")) {
              line.classList.add("completed");
            }
          }
        }
      }
    });

    // Check if all topics are completed and show celebration
    if (
      completedSections.length === totalSections &&
      completedQuizzes.length === totalSections
    ) {
      setTimeout(() => {
        showCelebration();
      }, 1000);
    }
  }

  // Confetti animation for celebration
  function createConfetti() {
    const colors = ["#5cdb95", "#88ccf1", "#f1c40f", "#e74c3c", "#9b59b6"];
    const confettiCount = 200;

    for (let i = 0; i < confettiCount; i++) {
      const confetti = document.createElement("div");
      confetti.className = "confetti";
      confetti.style.backgroundColor =
        colors[Math.floor(Math.random() * colors.length)];
      confetti.style.left = Math.random() * 100 + "vw";
      confetti.style.width = Math.random() * 10 + "px";
      confetti.style.height = Math.random() * 10 + "px";
      confetti.style.opacity = Math.random();
      confetti.style.animation = `fall ${
        Math.random() * 3 + 2
      }s linear forwards, sway ${
        Math.random() * 3 + 2
      }s ease-in-out infinite alternate`;
      document.body.appendChild(confetti);
    }
  }

  // Create trophy sparkles
  function createSparkles() {
    const sparkleContainer = document.getElementById("trophy-sparkle");
    if (!sparkleContainer) return;

    for (let i = 0; i < 15; i++) {
      const sparkle = document.createElement("span");
      sparkle.style.top = Math.random() * 100 + "%";
      sparkle.style.left = Math.random() * 100 + "%";
      sparkle.style.width = Math.random() * 4 + 2 + "px";
      sparkle.style.height = sparkle.style.width;
      sparkle.style.animationDelay = Math.random() * 2 + "s";
      sparkleContainer.appendChild(sparkle);
    }
  }

  function showCelebration() {
    // Only show if not already celebrated
    if (localStorage.getItem('malwareCelebrated') === 'true') return;
    localStorage.setItem('malwareCelebrated', 'true');

    const celebrationContainer = document.querySelector('.celebration-container');
    if (
      celebrationContainer &&
      !celebrationContainer.classList.contains('active')
    ) {
      celebrationContainer.classList.add('active');
      createConfetti();
      createSparkles();

      // Add navigation section if not present
      const content = celebrationContainer.querySelector('.celebration-content');
      if (content && !content.querySelector('.lesson-navigation')) {
        const navigationSection = document.createElement('div');
        navigationSection.className = 'lesson-navigation';
        navigationSection.innerHTML = `
          <div class="nav-container">
            <a href="learn.html" class="nav-button back">
              <i class="fas fa-arrow-left"></i> Back to Learning Hub
            </a>
            <a href="password-theft.html" class="nav-button next">
              Next Lesson: Password Security <i class="fas fa-arrow-right"></i>
            </a>
          </div>
        `;
        content.appendChild(navigationSection);
      }

      // Close celebration on button click
      const celebrationBtn = celebrationContainer.querySelector('.celebration-btn');
      if (celebrationBtn) {
        celebrationBtn.addEventListener('click', () => {
          celebrationContainer.classList.remove('active');
          setTimeout(() => {
            // Remove confetti to clean up
            document.querySelectorAll('.confetti').forEach((el) => el.remove());
          }, 500);
        });
      }
    }
  }

  const resetProgressBtn = document.getElementById("reset-progress");
  if (resetProgressBtn) {
    resetProgressBtn.addEventListener("click", function () {
      if (
        confirm(
          "Are you sure you want to reset your progress for this module? This cannot be undone."
        )
      ) {
        completedSections = [];
        completedQuizzes = [];
        let userId = null;
        if (firebase && firebase.auth && firebase.auth().currentUser) {
          userId = firebase.auth().currentUser.uid;
        } else {
          const localUser = JSON.parse(localStorage.getItem("currentUser"));
          if (localUser && localUser.uid) {
            userId = localUser.uid;
          }
        }
        if (userId) {
          // Save reset progress to Firebase
          if (firebase && firebase.database) {
            firebase.database().ref(`userProgress/${userId}/modules/malwareInfections`).update({
              completedSections: [],
              completedQuizzes: [],
              progressPercentage: 0,
              lastUpdated: firebase.database.ServerValue.TIMESTAMP
            });
          }
        }
        // Save to localStorage as backup
        localStorage.setItem("malwareCompletedSections", JSON.stringify([]));
        localStorage.setItem("malwareCompletedQuizzes", JSON.stringify([]));
        // Update UI
        updateTopicAccessibility();
        updateProgress();
        document.querySelectorAll(".topic-quiz-btn").forEach(btn => {
          btn.textContent = "Check Answer";
          btn.classList.remove("success");
          btn.disabled = false;
        });
        document.querySelectorAll(".option").forEach(opt => {
          opt.classList.remove("selected", "correct", "incorrect");
        });
        document.querySelectorAll(".topic-quiz-results").forEach(res => {
          res.style.display = "none";
        });
        document.querySelectorAll(".target-card").forEach(card => {
          card.classList.remove("completed");
        });
        // Show notification
        const container = document.querySelector(".container");
        const notification = document.createElement("div");
        notification.className = "notification";
        notification.textContent = "Progress reset successfully!";
        container.insertBefore(notification, container.firstChild);
        setTimeout(() => {
          notification.remove();
        }, 3000);
        // Clear celebration flag
        localStorage.removeItem('malwareCelebrated');
      }
    });
  }

  // Add click event to progress tracker nodes to scroll to corresponding topic
  document.querySelectorAll(".progress-node").forEach((node) => {
    node.addEventListener("click", function () {
      const topicId = this.getAttribute("data-topic");
      const topicCard = document.querySelector(
        `.target-card[data-target="${topicId}"]`
      );

      // Only scroll to accessible topics
      if (isTopicAccessible(topicId) && topicCard) {
        topicCard.scrollIntoView({ behavior: "smooth", block: "start" });
      } else {
        // Create a pulse animation on the locked topic
        this.classList.add("shake-animation");
        setTimeout(() => {
          this.classList.remove("shake-animation");
        }, 800);

        // Show a tooltip
        const container = document.querySelector(".container");
        const notification = document.createElement("div");
        notification.className = "notification";

        // Get the previous topic name for the message
        const topicIndex = topicOrder.indexOf(topicId);
        const prevTopicName =
          topicIndex > 0
            ? topicOrder[topicIndex - 1]
                .replace(/-/g, " ")
                .replace(/\b\w/g, (l) => l.toUpperCase())
            : "";

        notification.textContent = `Complete "${prevTopicName}" to unlock this topic.`;
        container.insertBefore(notification, container.firstChild);

        setTimeout(() => {
          notification.remove();
        }, 3000);
      }
    });
  });

  // Function to force a refresh of all progress indicators
  function refreshProgressIndicators() {
    console.log("[DEBUG] Forcing refresh of all progress indicators");
    
    // Update progress bar
    const progressBar = document.getElementById("module-progress");
    if (progressBar) {
      const progressPercentage = (completedSections.length / topicOrder.length) * 100;
      progressBar.style.width = `${progressPercentage}%`;
      
      // Force a repaint
      void progressBar.offsetWidth;
    }
    
    // Update progress tracker nodes
    document.querySelectorAll(".progress-node").forEach((node, index) => {
      const topicId = node.getAttribute("data-topic");
      if (!topicId) return;
      
      // Reset classes
      node.classList.remove("active", "completed", "locked");
      
      if (completedSections.includes(topicId) || completedQuizzes.includes(topicId)) {
        // Mark as completed
        node.classList.add("completed");
      } else if (isTopicAccessible(topicId)) {
        // Mark as active/in progress
        node.classList.add("active");
      } else {
        // Mark as locked
        node.classList.add("locked");
      }
      
      // Force a repaint
      void node.offsetWidth;
      
      // Update progress lines
      if (index > 0) {
        const prevNode = document.querySelectorAll(".progress-node")[index - 1];
        if (!prevNode) return;
        
        const prevTopicId = prevNode.getAttribute("data-topic");
        const progressLine = node.previousElementSibling;
        
        if (progressLine && progressLine.classList.contains("progress-line")) {
          if (completedSections.includes(prevTopicId) || completedQuizzes.includes(prevTopicId)) {
            progressLine.classList.add("completed");
          } else {
            progressLine.classList.remove("completed");
          }
          
          // Force a repaint
          void progressLine.offsetWidth;
        }
      }
    });
    
    // Make sure target cards show correct state
    topicOrder.forEach(topicId => {
      const card = document.querySelector(`.target-card[data-target="${topicId}"]`);
      if (!card) return;
      
      // Remove hardcoded lock overlays on completed or accessible topics
      if (completedSections.includes(topicId) || 
          completedQuizzes.includes(topicId) || 
          isTopicAccessible(topicId)) {
        
        card.classList.add("accessible");
        
        // Remove any debugging lock overlay that might be present
        const debugLockOverlay = card.querySelector(".debug-lock-overlay");
        if (debugLockOverlay) {
          debugLockOverlay.style.display = "none";
        }
        
        // Remove any grayscale filter
        card.style.filter = "none";
        card.style.pointerEvents = "auto";
        
        // Enable all interactive elements
        card.querySelectorAll(".attack-item, .topic-quiz .option, .topic-quiz-btn")
          .forEach(el => {
            el.style.pointerEvents = "auto";
          });
      }
      
      // Mark completed cards
      if (completedSections.includes(topicId) || completedQuizzes.includes(topicId)) {
        card.classList.add("completed");
      }
    });
    
    // Force a general repaint to ensure all changes are visible
    document.body.style.opacity = "0.99";
    setTimeout(() => {
      document.body.style.opacity = "1";
    }, 50);
  }

  // Check if quizzes are disabled
  const quizzesDisabled = localStorage.getItem("quizzesDisabled") === "true";
  
  // If quizzes are disabled, hide all quiz sections
  if (quizzesDisabled) {
    const quizSections = document.querySelectorAll('.topic-quiz');
    quizSections.forEach(section => {
      section.style.display = 'none';
    });
    
    // Add a message that quizzes are disabled
    const targetCards = document.querySelectorAll('.target-card');
    targetCards.forEach(card => {
      // Check if message already exists
      if (!card.querySelector('.quizzes-disabled-message')) {
        const message = document.createElement('p');
        message.className = 'quizzes-disabled-message';
        message.innerHTML = '<i class="fas fa-info-circle"></i> Quizzes are currently disabled. You can enable them in your <a href="profile.html">profile settings</a>.';
        message.style.color = '#88ccf1';
        message.style.padding = '10px 15px';
        message.style.backgroundColor = 'rgba(52, 148, 201, 0.1)';
        message.style.borderRadius = '5px';
        message.style.marginTop = '15px';
        card.appendChild(message);
      }
    });
  }
});

// Define logout function
function logout() {
  // Check if Firebase auth is available
  if (firebase && firebase.auth) {
    firebase
      .auth()
      .signOut()
      .then(() => {
        // Remove current user from localStorage for backward compatibility
        localStorage.removeItem("currentUser");
        // Redirect to login page
        window.location.href = "login.html";
      })
      .catch((error) => {
        console.error("Sign out error:", error);

        // Fallback to local logout if Firebase fails
        localStorage.removeItem("currentUser");
        window.location.href = "login.html";
      });
  } else {
    // Fallback for older version
    localStorage.removeItem("currentUser");
    window.location.href = "login.html";
  }
}
